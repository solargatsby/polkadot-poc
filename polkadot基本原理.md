<h2>基本架构</h2>
Polkadot是一条异构的多链系统，旨在提供一个可以跨链交互的一种区块链网络。

Polkadot从"Polkadot PoC-2"版本开始，把核心代码进行抽象成Substrate，并在Substrate之上构建Polkadot。

Substrate被设想为下一代区块链开发基础框架，主要提供以下功能：

- 共识算法基础——包含libp2p网络层封装、生产区块等基础功能，开包即用；
- 自定义的状态转换函数——维护世界状态，可自定义交易的状态转换函数；
- 链上治理方案——可通过投票对区块链运行时进行升级。

区块链开发者可以基于Substrate可以快速建立自己的区块链，免去构建底层网络、共识机制的繁琐工作，专注于业务功能的开发。Substrate也是Polkadot主链和平行链开发的基础。

<h3>网络组成</h3>

Polkadot网络主要包含：中继链（Relay Chain）、平行链 （Parachains）、桥接（Bridges）、验证人（Validators）、收集人（Collators）、钓鱼人（Fishermen）

![polkadot network](http://wiki.polkadot.network/docs/assets/polkadot_relay_chain.png)

- 中继链（Relay Chain）

中继链是Polkadot的核心区块链结构，中继链管理抵押、共识、治理等，也负责确保平行链之间的消息传递。中继链本身和其他区块链类似，但Polkadot协议希望中继链不处理具体的应用业务逻辑，转而由平行链提供。

中继链包含运行时环境（Polkadot Runtime Environment，PRE）和运行时（Runtime），其中运行时包含中继链的运行时和平行链的运行时。这里提到的运行时和运行时环境是不一样的。运行时环境是本地可执行代码，无法通过治理机制升级；而运行时则是存储在链上的WebAssembly（Wasm）代码，可以通过治理机制完成链上升级。

中继链管理验证人Dot代币的抵押、奖励、罚没，所有的验证人首先需要连接到中继链上进行工作，然后才会被分配到平行链处理区块验证工作。

平行链和中继链的运行时可以使用Substrate进行开发，也可以使用任何支持WebAssembly的语言开发。


- 平行链 （Parachains）

平行链一般为特定应用的区块链，平行链以运行时的形式把逻辑代码（Wasm）存储在中继链上，供验证人执行验证。平行链不需要有自己的共识机制（也不能有，如果有就不是平行链，而是通过桥的形式接入的独立区块链），而是使用Polkadot提供的共享安全机制。

平行链代码架构一般包含：平行链运行时、收集人节点。

平行链的是独立出块成链，所有平行链并行运行，这保证了Polkadot系统性能和功能可扩展性。平行链的区块通过验证人验证后，其区块头将会被包含在中继链中。


- 桥接（Bridges）

有独立共识机制、不能成为平行链的区块链（如比特币、以太坊），可以通过桥的形式接入Polkadot，获得跨链通讯的能力。桥接（链）也是特殊的平行链。

桥接没有固定的形式，根据所桥接的链的技术特点而定。对于比特币的桥接，可能是通过由信托节点持有的多签地址来处理比特币的转入和转出；而对于实现图灵完备虚拟机的以太坊，则可以通过“外向合约”实现更广义的跨链通讯。


- 验证人（Validators）

验证人运行全节点并负责把验证过的区块加到中继链中。验证人不产生平行链区块（产生平行链区块是收集人的事情），它负责验证平行链区块，它从收集人接受并验证候选平行链区块，并把有效平行链区块的区块头加入到中继链区块中。

验证人需要抵押Dot到中继链上，成为验证人，验证人同时也接受提名人的投票。Polkadot最多可以有1000个验证人，然后通过Polkadot randomness cycle随机算法把验证人平均分配给100个平行链进行验证。

验证人可以获得Dot奖励，值得注意的是，1000个验证人中每个验证人在每轮获取的奖励都是一样的，与验证人的抵押数、票数无关。验证人获得奖励后，可选择扣下一部分，剩下的根据验证人自身抵押量和提名人抵押量进行等比例分配。


- 收集人（Collators）

有些文章翻译成收集人，收集人属于平行链，收集人收集交易、产生区块，把区块提交给中继链分配给该平行链的验证人。同时，收集人也负责平行链之间消息的路由，它会产生一个出口消息队列，也会从其他平行链获取一个入口队列，并打包金区块中。

Polkadot并没有规定收集人的抵押和奖励，这部分可以由平行链的经济系统来决定，平行链可以由自己的代币（也可以没有），可以通过通胀模型或最小手续费的方式对收集人进行激励。


- 钓鱼人（Fishermen）

钓鱼人的角色类似于“赏金猎人”，无需抵押，只有通过证明验证人作恶，罚没验证人押金获得奖励。


<h2>平行链与平行线程</h2>

<h3>平行链</h3>
平行链是特定于应用程序的数据结构，它在上下上是一致的，并且可以由 Polkadot 中继链的验证人进行验证。 通常平行链会是一条区块链, 但并没有特别要求它们必须是一条链，之所以叫他们平行链是因为它们于中继链并行运行。 由于它们的并行性质，它们能够并行地处理交易并实现 Polkadot 系统的可伸缩性。它们与 Polkadot 网络共享安全，并且可以通过 XCMP 与其它平行链进行通信。

平行链可能有自己的经济体和自己的原生币。方案像权益证明通常用于选择验证人以便用于验证区块和确定性。平行链并不需要处理以上功能。 但是由于 Polkadot 对于平行链可以实现的内容也是通用的，因此平行链可以选择实现抵押代币，但通常没有必要。

收集人可能通过平行链的原生币通胀来激励。 可能还有其他方法可以激励收集人而不需要通胀平行链原生币。

平行链也可实现使用原生币作为交易费用 。 Polkadot 对平行链如何决定交易的原有 有效性没有硬性规定。例如平行链可以实现必须支付小额费用给收集人才能有效。中继链将强制执行此有效性。同样平行链不能包括他们的实现和 Polkadot 仍将强制执行其有效性。

Polkadot 的卡槽数量是有限的，平行链需要通过竞拍的方式获得卡槽才能接入Polkadot 网络。

<h3>平行线程</h3>
由于卡槽拍卖需要巨大的成本，对于一些轻量级的程序，没有必要花费巨大的成本去竞拍平行链卡槽。为此 Polkadot提供了另一种选择，那就是平行线程。

波卡将为平行线程池保留一些平行链插槽。池中可以存在任意数量的平行线程，但是每个区块中只能执行有限的数量。
在每个中继链区块中，并行线程将通过参与拍卖来发出其执行一个区块的意愿。平行线程收集人（collator）将告诉分配给池的验证人，它们愿意支付多少 DOT 以执行和完成其区块。按区块付费模式不同于平行链，平行链有权通过其专用插槽在每个中继链区块中执行一个区块。

平行线程可以通过多种方式为区块执行提供资金。例如，它们可以筹集资金，并为其链拥有一个 DOT 帐户，并让收集人使用该帐户，以便在需要时终结（finalize）区块。另外，平行线程可以具有一个通货膨胀模型，该模型可以在中继链运行时向收集人提供更多的本地代币。一旦本地代币的价值超过赢得拍卖所需的 DOT 的价值，则收集人将接受区块奖励。

<h2>Polkadot共识</h2>

Polkadot共识主要有三个部分 NPOS, BABE 和 GRANDPA。

<h3>NPOS</h3>

在Polkadot 中，中继链上的验证者需要分配到各个平行链，为它们提供区块链验证能力，是 Polkadot 共享安全性的一部分。
NPOS( Nominated Proof of Stake)共识算法就是用来选举出能让系统更安全，更高效的验证者集合的。

下面看看NPOS是如何进行工作的。
在说明NPOS之前，我们需要先回顾一下Polkadot中重要的两种角色。

**验证人**

中继链的全节点，中继链会在验证人池中通过随机分组把验证人指定给不同的平行链。验证人会接受来自收集人打包的区块并进行有效性验证，然后结合共识算法对收集人提交的区块进行确认。

**提名人**

Polkadot中数字货币DOT的持有人，它会选择自己所信任的验证人进行DOT质押，然后分享验证人的收益。

Polkadot的选举模型是建立在这两种角色基础上的。要成为验证人，必须先成为验证人候选人参加选举的过程，而这个选举过程中的“选民”就是提名人。

在Polkadot的设计中，提名人数量在理论是可以不设置上限的，如果能够让更多的提名者参与到投票阶段，那么参与到选举的资金量也就越大，整个系统就更加的安全；而对于验证者来说，为了区块链的性能，不能太多（所有节点都能作为验证者的话，那就是比特币采用的模式了），验证者的数量由系统确定的固定值，这一点来说和POS共识是一致的。


<h3>BABE</h3>

BABE的全称是Blind Assignment for Blockchain Extension，BABE是一个用来出块的引擎，BABE算法是基于slots的。

在Polkadot中每一个slot差不多6秒长的时间。

每个slot时间段中BABE会选出一个leader来出块。

BABE中leader的选举是通过一个随机函数（VRF）来实现的，在每个slot阶段，每一个节点会通过运算VRF函数来获得一个数值，如果这个数值小于网络中预先规定好的阈值，那么节点就会认为自己就是这个时间段的leader，于是节点就开始出块了。

值得注意的是在上述的过程中，由于VRF函数是随机生成数字的，所以可能造成在某一slot中没有leader或者有多个节点算出自己的VRF值小于阈值进而产生多个leader的情况。我们依次分析两种情况：

当没有leader产生时，Polkadot就规定按照顺序来决定谁是leader，这个顺序是预先确定好的。

当出现多个leader的时候，Polkadot允许多个节点都提交区块，而最终区块的确认则由GRANDPA来决定。


<h3>GRANDPA</h3>

GRANDPA则是用来做区块确认的，在文章的第二部分我们有提到BABE将会对Polkadot的交易进行出块，那么这些出块最终就是由GRANDPA来确定的。

像其他PBFT的衍生算法一样，GRANDPA的时间复杂度也是O(n)。但是Polkadot之所以采用GRANDPA是因为GRANDPA并不是每次只确认一个区块，它每一次都会确定好几个区块来做确认。

GRANDPA的具体流程：

1. 一个主节点广播之前一轮确认后的区块高度；

2. 等待网络延迟以后，每个节点都广播他们认为的可以被确认的最高的区块（pre-vote）；

3. 每个节点对步骤2接受到的区块集进行计算，算出他们认为的能够被确认的最高区块，并且将结果广播出去(pre-commit)；

4. 当节点接收到足够的pre-commit的消息能够确认区块后就会形成commit的消息，一般认为大于2/3就可以被确认了。

我们需要担心的是在步骤2的pre-vote过程中可能会有作恶的节点投票了两个区块并且广播出去，这样的话就有可能产生链的分叉行为。

Polkadot为了防止这种情况的发生使用了一个叫做Account Safety的方式。

如果当网络中出现了要分叉的commit信息时，Polkadot的节点会马上采取Account Safety的机制。每个节点都会询问其他节点他们所看到的pre-vote的情况，节点都会回复他们收到的信息，这样就很容易检查到有哪些恶意节点投了两个区块。最后这些被抓到的作恶节点将会被踢出共识网络，永远不能进入。

让我们回到BABE，通过结合BABE和GRANDPA我们可以看到在出块的时候Polkadot采用BABE出块，此时节点之间只要发送一次块信息即可，这样的话时间复杂度仅仅是O(n)，在出块之后节点之间再采用GRANDPA进行块确认，此时由于确认阶段节点之间要通过二次确认来保证确认块结果的一致性，时间复杂度是O(n)，不过由于是多个块一次性进行确认，所以两者结合的混合共识是非常高效的，比普通的PBFT共识要高效很多。


参考资料:

[Polkadot协议网络结构和角色简介](https://zhuanlan.zhihu.com/p/80360972)

[Polkadot 波卡平行线程：“随用随付” 的平行链](https://baijiahao.baidu.com/s?id=1677969740203703502&wfr=spider&for=pc)

[https://baijiahao.baidu.com/s?id=1676898665505426399&wfr=spider&for=pc](https://baijiahao.baidu.com/s?id=1676898665505426399&wfr=spider&for=pc)
